# 목차
  1. SW 문제해결
  2. 알고리즘 복잡도
  3. 비트 연산
  4. 진법
  5. 실수
---
## 1. SW 문제 해결
  - 문제 해결 과정에 대한 이해가 필요하다.
  - 문제 해결을 위한 접근 방법과 과정을 알아야 한다.

## 2. 알고리즘 복잡도 
  - 알고리즘 성능 측정을 위한 복잡도 이론
  - 시간 복잡도와 공간 복잡도 개념
  - 복잡도 분석을 통한 알고리즘 호율성 판단 방법

  ### 알고리즘 성능 측정을 위한 복잡도 이론
  알고리즘의 성능을 평가하기 위해서는 시간 복잡도와 공간 복잡도라는 두 가지 주요 개념을 사용합니다.
  이들은 각각 알고리즘이 실행되는 데 걸리는 시간과 사용하는 메모리의 양을 측정하는 지표입니다.
  이러한 복잡도 분석은 알고리즘의 효율성을 판단하고, 다양한 입력 크기에 대한 성능을 예측하는 데 중요한 역할을 합니다.

  ### 시간 복잡도와 공간 복잡도 개념
  
### **시간 복잡도(Time Complexity)**
시간 복잡도는 알고리즘이 주어진 입력 크기 *n*에 따라 얼마나 많은 시간이 소요되는지를 나타냅니다. 
일반적으로 **Big O 표기법**을 사용하여 표현하며, 이는 알고리즘의 최악의 경우 실행 시간을 상한선으로 나타냅니다.

시간 복잡도의 대표적인 예시는 다음과 같습니다:

- **O(1)**: 상수 시간 복잡도로, 입력 크기에 상관없이 일정한 시간이 소요됩니다.
- **O(log n)**: 로그 시간 복잡도로, 입력 크기가 커질수록 시간은 로그 함수에 비례해 증가합니다.
- **O(n)**: 선형 시간 복잡도로, 입력 크기에 비례하여 시간이 증가합니다.
- **O(n²)**: 이차 시간 복잡도로, 입력 크기의 제곱에 비례해 시간이 증가합니다.

### **공간 복잡도(Space Complexity)**

공간 복잡도는 알고리즘이 실행되면서 사용하는 메모리의 양을 나타냅니다. 마찬가지로 Big O 표기법을 사용하여 표현하며, 
입력 크기에 따른 메모리 사용량의 변화를 설명합니다

예를 들어:

- **O(1)**: 상수 공간 복잡도로, 입력 크기와 관계없이 일정한 메모리만 사용합니다.
- **O(n)**: 선형 공간 복잡도로, 입력 크기에 비례해 메모리를 사용합니다.

### 알고리즘 효율성을 개선하는 방법
알고리즘의 효율성을 높이기 위해서는 다음과 같은 방법들이 사용될 수 있습니다:

- 더 적은 연산으로 동일한 결과를 도출하는 최적화된 알고리즘 설계
- 적절한 데이터 구조 선택 (예: 해시 테이블 vs 배열)
- 반복적인 연산 대신 메모이제이션(Memoization) 기법 활용

따라서 코딩 테스트나 실제 개발에서 알고리즘을 설계할 때는 시간과 공간 복잡도를 모두 고려하여 
최적의 성능을 내는 방안을 찾는 것이 중요합니다.

- 비트 연산 개념
- 비트 연산을 활용한 문제 해결 방법

## 3. **비트 연산 개념**

**비트 연산**

은 컴퓨터에서 데이터를

**비트 단위**

로 처리하는 연산입니다. 모든 데이터는 0과 1로 이루어진 이진수로 표현되며, 비트 연산은 이러한 이진수를 직접 다루는 연산입니다. 비트 연산은 매우 빠르고 메모리 효율이 높기 때문에, 특히 **저수준 프로그래밍** 이나 **알고리즘 최적화** 에서 자주 사용됩니다.

비트 연산에는 다음과 같은 주요 연산자들이 있습니다:

- **AND (`&`)**: 두 비트가 모두 1일 때만 결과가 1이 됩니다. 이를 통해 특정 비트를 마스크(mask)하여 선택적으로 값을 추출할 수 있습니다.
- **OR (`|`)**: 두 비트 중 하나라도 1이면 결과가 1이 됩니다. 특정 비트를 설정(set)할 때 유용합니다.
- **XOR (`^`)**: 두 비트가 다를 때만 결과가 1이 됩니다. 이를 통해 특정 비트를 토글(toggle)하거나 두 값이 같은지 비교할 수 있습니다.
- **NOT (`~`)**: 모든 비트를 반전시킵니다. 즉, 0을 1로, 1을 0으로 바꿉니다.
- **왼쪽 시프트 (`<<`)**: 비트를 왼쪽으로 이동시키며, 이동한 만큼 값은 2의 배수로 증가합니다.
- **오른쪽 시프트 (`>>`)**: 비트를 오른쪽으로 이동시키며, 이동한 만큼 값은 2로 나눈 결과가 됩니다

예시

```jsx
int a = 5;   // 0101 (2진수)
int b = 3;   // 0011 (2진수)

int and_result = a & b; // 0001 -> 결과는 1
int or_result = a | b;  // 0111 -> 결과는 7
int xor_result = a ^ b; // 0110 -> 결과는 6
int not_result = ~a;    // 반전된 값 -> -6 (2의 보수 표현)
```

## **비트 연산을 활용한 문제 해결 방법**

비트 연산은 다양한 알고리즘 문제에서 효율적인 해결책을 제공합니다. 특히, **시간 복잡도와 공간 복잡도**를 줄이는 데 큰 도움이 됩니다. 아래는 비트 연산을 활용한 몇 가지 대표적인 문제 해결 방법입니다.

### **1. 집합 표현 및 조작**

비트를 사용하여 집합을 표현할 수 있습니다. 예를 들어, 각 비트를 집합의 원소에 대응시켜, 특정 원소가 포함되었는지를 쉽게 확인할 수 있습니다.

- **교집합(AND)**: 두 집합의 공통 원소를 구할 때 사용합니다.
- **합집합(OR)**: 두 집합의 모든 원소를 구할 때 사용합니다.
- **차집합(AND + NOT)**: 한 집합에서 다른 집합의 원소를 제거할 때 사용합니다.

### **2. 특정 비트 확인 및 설정**

특정 위치의 비트를 확인하거나 설정하는 작업은 매우 자주 사용됩니다.

- **비트 확인**: **`x & (1 << k)`**는 정수 **`x`**의 **`k`**번째 비트가 1인지 확인하는 방법입니다.
- **비트 설정**: **`x | (1 << k)`**는 **`x`**의 **`k`**번째 비트를 1로 설정합니다.

### **3. XOR을 이용한 스왑**

두 변수를 추가적인 메모리 없이 XOR 연산을 통해 교환할 수 있습니다.

```jsx
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

### **4. 홀수/짝수 판별**

숫자가 홀수인지 짝수인지를 빠르게 판단하려면 ‘x & 1’ 을 사용할 수 있습니다. 결과가 0이면 짝수, 그렇지 않으면 홀수입니다.

### **5. 빠른 곱셈 및 나눗셈**

비트 시프트를 사용하여 곱셈과 나눗셈을 최적화할 수 있습니다.

- **`x << n`**: *x*×2*n* (곱셈)
    
    x×2n
    
- **`x >> n`**: *x*/2*n* (나눗셈)
    
    x/2n
    

### **6. 하드웨어 제어 및 최적화**

비트 연산은 하드웨어 제어와 같은 저수준 프로그래밍에서 매우 유용합니다. 예를 들어, LED나 센서와 같은 장치 제어에서 특정 핀을 켜거나 끄기 위해 비트 마스크와 시프트 연산이 자주 사용됩니다.

## **결론**

비트 연산은 알고리즘 문제 해결에서 매우 강력한 도구입니다. 이를 잘 활용하면 메모리와 시간을 절약하면서도 효율적인 코드를 작성할 수 있습니다.

- 진법의 개념과 이해
- 10진법, 2진법, 16진법 등 다양한 진법 변환 방법

## 4. 진법의 개념과 이해

**진법**은 숫자를 표현하는 방식 중 하나로, **기수** 라고도 불립니다. 진법은 숫자를 나타내기 위해 사용하는 **기본 숫자의 개수**를 의미합니다. 예를 들어, **10진법**은 0부터 9까지 10개의 숫자를 사용하고, **2진법**은 0과 1 두 개의 숫자만을 사용합니다. 진법에서 숫자의 자릿값은 각 자리에 해당하는 기수의 거듭제곱으로 계산됩니다.

## **주요 진법**

- **10진법(Decimal)**: 우리가 일상적으로 사용하는 수 체계로, 0에서 9까지의 숫자를 사용합니다.
- **2진법(Binary)**: 컴퓨터에서 사용하는 수 체계로, 0과 1 두 개의 숫자만을 사용합니다.
- **8진법(Octal)**: 0에서 7까지의 숫자를 사용하는 진법입니다.
- **16진법(Hexadecimal)**: 0에서 9까지의 숫자와 A(10)부터 F(15)까지 총 16개의 기호를 사용하는 진법입니다.

## **10진법, 2진법, 16진법 등 다양한 진법 변환 방법**

### **1. 10진수를 다른 진법으로 변환**

10진수를 다른 진법으로 변환하는 방법은 **나눗셈을 이용한 방법**입니다. 변환하려는 진수로 계속 나누고, 나머지를 기록한 후 역순으로 읽으면 변환된 값을 얻을 수 있습니다.

### **예시: 10진수를 2진수로 변환**

10진수 13을 2진수로 변환하는 과정을 살펴보겠습니다.

1. **`13 ÷ 2 = 6`**, 나머지 **`1`**
2. **`6 ÷ 2 = 3`**, 나머지 **`0`**
3. **`3 ÷ 2 = 1`**, 나머지 **`1`**
4. **`1 ÷ 2 = 0`**, 나머지 **`1`**

나머지를 역순으로 읽으면 **1101** 이므로, **13** 은 이진수로 **1101** 입니다.

### **예시: 10진수를 16진수로 변환**

10진수 **254**를 16진수로 변환하는 과정을 살펴보겠습니다.

1. **`254 ÷ 16 = 15`**, 나머지 **`14`** (16진수에서 **`14`**는 **`E`**)
2. **`15 ÷ 16 = 0`**, 나머지 **`15`** (16진수에서 **`15`**는 **`F`**)

나머지를 역순으로 읽으면 **FE**가 되므로, **254**는 16진수로 **FE**입니다.

### **2. 다른 진법을 10진수로 변환**

다른 진법을 다시 **10진수로 변환**할 때는 각 자리의 수에 해당하는 기수의 거듭제곱 값을 곱한 후 모두 더해줍니다.

### **예시: 이진수를 십진수로 변환**

이진수 **1101**

을 십진수로 변환하는 과정을 살펴보겠습니다.

11012=(1×23)+(1×22)+(0×21)+(1×20)11012=(1×23)+(1×22)+(0×21)+(1×20)

=(8)+(4)+(0)+(1)=13=(8)+(4)+(0)+(1)=13

따라서, 이진수 **1101**은 십진수로 **13** 입니다.

### **예시: 16진수를 십진수로 변환**

16진수 **FE**를 십진수로 변환하는 과정을 살펴보겠습니다.

FE16=(15×161)+(14×160)*FE*16=(15×161)+(14×160)

=(240)+(14)=254=(240)+(14)=254

따라서, **FE**는 십진수로 **254**입니다.

### **3. 다른 진법 간의 직접 변환**

때때로 두 진법 간에 직접 변환할 수 있습니다. 특히,**2진수와 8진수**, 그리고 **2진수와 16진수** 간에는 쉽게 변환할 수 있습니다.

### **이진수를 바로 팔진수로 변환**

이진수를 세 자리씩 묶어서 각 그룹을 대응되는 팔진수 값으로 바꾸면 됩니다.

- 예시: 이진수 **`11010111`**
    - 세 자리씩 묶으면: **`(110)(101)(11)`** → 앞에 자리를 채워 **`(110)(101)(011)`**
    - 각 그룹을 팔진수로 바꾸면: **`(6)(5)(3)`** → 팔진수는 **`653`**

### **이진수를 바로 십육진수로 변환**

이 경우 네 자리씩 묶어서 각 그룹을 대응되는 십육진수 값으로 바꿉니다.

- 예시: 이진수 **`11010111`**
    - 네 자리씩 묶으면: **`(1101)(0111)`**
    - 각 그룹을 십육진수로 바꾸면: **`(D)(7)`** → 십육진수는 **`D7`**

## **결론**

다양한 진법 간의 변환은 프로그래밍 및 컴퓨터 시스템에서 매우 중요한 개념입니다. 특히 컴퓨터가 내부적으로 이진수를 사용하기 때문에, 이와 관련된 문제를 해결하기 위해서는 여러 진법 간의 상호 변환을 숙지하는 것이 필수적입니다.

- 실수 데이터 타입의 특징
- 실수 계산 시 발생하는 오차와 오차 해결 방법

## 5. **실수 데이터 타입의 특징**

**실수 데이터 타입**

은 컴퓨터에서

**부동소수점(floating-point)**

방식으로 실수를 표현합니다. 이는 매우 큰 수나 매우 작은 수를 효율적으로 처리할 수 있도록 설계된 데이터 타입입니다. 실수 데이터는 **유효숫자(mantissa)**와 **지수(exponent)**로 나뉘어 저장되며, 이러한 구조 덕분에 다양한 범위의 실수를 표현할 수 있지만, 정확도에는 한계가 있습니다 

.실수 데이터 타입의 주요 특징은 다음과 같습니다:

- **근사적 표현**: 실수는 무한한 자릿수를 가질 수 있지만, 컴퓨터는 유한한 메모리만을 사용하므로 실수를 근사적으로 표현합니다.
- **범위와 정밀도의 트레이드오프**: 더 많은 메모리를 할당할수록 더 높은 정밀도로 실수를 표현할 수 있습니다. 예를 들어, **`float`**는 32비트로 7자리의 십진수를 표현하고, **`double`**은 64비트로 15자리의 십진수를 표현합니다.
- **범용성**: 대부분의 프로그래밍 언어에서 실수 타입은 양수와 음수를 모두 지원하며, 매우 큰 값과 매우 작은 값을 모두 다룰 수 있습니다.

| **언어** | **예약어** | **크기** | **정밀도** | **범위** |
| --- | --- | --- | --- | --- |
| C++ | **`float`** | 32비트 / 4바이트 | 7자리 | ±3.40282347E+38 |
| C++ | **`double`** | 64비트 / 8바이트 | 15자리 | ±1.79769313486231570E+308 |
| Python | **`float()`** | 64비트 / 8바이트 | 15자리 | ±1.79769313486231570E+308 |

## **실수 계산 시 발생하는 오차와 오차 해결 방법**

## **실수 계산에서 발생하는 오차**

실수 계산에서는 **반올림 오차(rounding error)**와 같은 문제로 인해 정확한 결과를 얻지 못할 수 있습니다. 이는 주로 다음과 같은 이유에서 발생합니다:

- **유한한 비트로 무한 소수를 표현**: 예를 들어, 소수점 아래 무한히 이어지는 숫자(예: 0.1)는 부동소수점 방식으로 정확하게 표현되지 않으며, 근사값으로 저장됩니다. 이로 인해 계산 결과가 미세하게 달라질 수 있습니다.

```jsx
a = 0.1
print(f"{a:.20f}") *# 출력: 0.10000000000000000555*
```

- **연산 순서에 따른 오차 누적**: 특히 덧셈과 뺄셈 같은 연산에서 큰 숫자와 작은 숫자를 함께 계산하면 작은 숫자의 유효숫자가 손실될 수 있습니다[3](https://floating-point-gui.de/errors/propagation/). 예를 들어, 매우 큰 수에 작은 수를 더하거나 빼면 작은 수가 무시되거나 왜곡될 가능성이 큽니다.
    
    ```jsx
    b = a + 1
    print(a == b) *# 출력: True (1이 더해지지 않음)*
    ```
    
- **연산의 비결합성**: 부동소수점 연산에서는 덧셈이나 곱셈이 결합법칙을 따르지 않을 수 있습니다. 즉, **`(a + b) + c`**와 **`a + (b + c)`**의 결과가 다를 수 있습니다[5](https://zingale.github.io/comp_astro_tutorial/basics/floating-point/numerical_error.html).

## **오차 해결 방법**

실수 계산에서 발생하는 오차를 줄이기 위한 몇 가지 방법이 있습니다:

1. **정확한 비교 대신 허용 오차 사용**
    - 부동소수점 연산에서는 두 실수를 직접 비교해서는 안 됩니다. 대신 두 값의 차이가 특정 허용 오차(예: 10^−6) 이내인지 확인하는 방식으로 비교해야 합니다.
        
        
    
    ```jsx
    def is_close(a, b, tol=1e-6):
        return abs(a - b) < tol
    ```
    
2. **반올림 처리**
    - 계산 결과를 출력하거나 사용할 때 미리 반올림하여 불필요한 소숫점 이하 자릿수를 제거하는 것도 좋은 방법입니다[2](https://forums.ni.com/t5/LabVIEW/How-do-you-guys-deal-with-floating-point-errors/td-p/4208871). 이를 통해 미세한 부동소수점 오류가 눈에 띄지 않도록 할 수 있습니다.
    
    ```jsx
    result = round(0.33333333333, 2) *# 출력: 0.33*
    ```
    
3. **연산 순서 변경**
    - 연산 순서를 재배치하여 오차를 줄일 수 있습니다. 예를 들어, 큰 숫자와 작은 숫자를 더하거나 빼는 연산보다는 비슷한 크기의 숫자끼리 먼저 연산하는 것이 좋습니다.
4. **고정 소수점 연산 사용**
    - 부동소수점 대신 고정 소수점 방식을 사용하는 것도 한 가지 방법입니다. 고정 소수점 방식은 정밀도가 고정되어 있어 특정 상황에서 더 정확한 결과를 제공할 수 있습니다.
5. **다른 알고리즘 선택**
    - 일부 알고리즘은 부동소수점 연산에서 상대적으로 안정적이며, 일부는 불안정합니다. 안정적인 알고리즘을 선택하면 오차가 누적되는 것을 방지할 수 있습니다.

## **결론**

실수 데이터 타입은 넓은 범위의 숫자를 다룰 수 있는 장점을 가지고 있지만, 근사적 표현으로 인해 계산 시 오차가 발생할 수 있습니다. 이러한 오차는 허용 오차 설정, 반올림 처리, 연산 순서 최적화 등의 방법을 통해 해결하거나 최소화할 수 있으며, 이를 통해 보다 정확한 결과를 얻을 수 있습니다.
