# 목차
  1. SW 문제해결
  2. 알고리즘 복잡도
  3. 비트 연산
  4. 진법
  5. 실수
---
## 1. SW 문제 해결
  - 문제 해결 과정에 대한 이해가 필요하다.
  - 문제 해결을 위한 접근 방법과 과정을 알아야 한다.

## 2. 알고리즘 복잡도 
  - 알고리즘 성능 측정을 위한 복잡도 이론
  - 시간 복잡도와 공간 복잡도 개념
  - 복잡도 분석을 통한 알고리즘 호율성 판단 방법

  ### 알고리즘 성능 측정을 위한 복잡도 이론
  알고리즘의 성능을 평가하기 위해서는 시간 복잡도와 공간 복잡도라는 두 가지 주요 개념을 사용합니다.
  이들은 각각 알고리즘이 실행되는 데 걸리는 시간과 사용하는 메모리의 양을 측정하는 지표입니다.
  이러한 복잡도 분석은 알고리즘의 효율성을 판단하고, 다양한 입력 크기에 대한 성능을 예측하는 데 중요한 역할을 합니다.

  ### 시간 복잡도와 공간 복잡도 개념
  
### **시간 복잡도(Time Complexity)**
시간 복잡도는 알고리즘이 주어진 입력 크기 *n*에 따라 얼마나 많은 시간이 소요되는지를 나타냅니다. 
일반적으로 **Big O 표기법**을 사용하여 표현하며, 이는 알고리즘의 최악의 경우 실행 시간을 상한선으로 나타냅니다.

시간 복잡도의 대표적인 예시는 다음과 같습니다:

- **O(1)**: 상수 시간 복잡도로, 입력 크기에 상관없이 일정한 시간이 소요됩니다.
- **O(log n)**: 로그 시간 복잡도로, 입력 크기가 커질수록 시간은 로그 함수에 비례해 증가합니다.
- **O(n)**: 선형 시간 복잡도로, 입력 크기에 비례하여 시간이 증가합니다.
- **O(n²)**: 이차 시간 복잡도로, 입력 크기의 제곱에 비례해 시간이 증가합니다.

### **공간 복잡도(Space Complexity)**

공간 복잡도는 알고리즘이 실행되면서 사용하는 메모리의 양을 나타냅니다. 마찬가지로 Big O 표기법을 사용하여 표현하며, 
입력 크기에 따른 메모리 사용량의 변화를 설명합니다

예를 들어:

- **O(1)**: 상수 공간 복잡도로, 입력 크기와 관계없이 일정한 메모리만 사용합니다.
- **O(n)**: 선형 공간 복잡도로, 입력 크기에 비례해 메모리를 사용합니다.

### 알고리즘 효율성을 개선하는 방법
알고리즘의 효율성을 높이기 위해서는 다음과 같은 방법들이 사용될 수 있습니다:

- 더 적은 연산으로 동일한 결과를 도출하는 최적화된 알고리즘 설계
- 적절한 데이터 구조 선택 (예: 해시 테이블 vs 배열)
- 반복적인 연산 대신 메모이제이션(Memoization) 기법 활용

따라서 코딩 테스트나 실제 개발에서 알고리즘을 설계할 때는 시간과 공간 복잡도를 모두 고려하여 
최적의 성능을 내는 방안을 찾는 것이 중요합니다.

- 비트 연산 개념
- 비트 연산을 활용한 문제 해결 방법

## 3. **비트 연산 개념**

**비트 연산**

은 컴퓨터에서 데이터를

**비트 단위**

로 처리하는 연산입니다. 모든 데이터는 0과 1로 이루어진 이진수로 표현되며, 비트 연산은 이러한 이진수를 직접 다루는 연산입니다. 비트 연산은 매우 빠르고 메모리 효율이 높기 때문에, 특히 **저수준 프로그래밍** 이나 **알고리즘 최적화** 에서 자주 사용됩니다.

비트 연산에는 다음과 같은 주요 연산자들이 있습니다:

- **AND (`&`)**: 두 비트가 모두 1일 때만 결과가 1이 됩니다. 이를 통해 특정 비트를 마스크(mask)하여 선택적으로 값을 추출할 수 있습니다.
- **OR (`|`)**: 두 비트 중 하나라도 1이면 결과가 1이 됩니다. 특정 비트를 설정(set)할 때 유용합니다.
- **XOR (`^`)**: 두 비트가 다를 때만 결과가 1이 됩니다. 이를 통해 특정 비트를 토글(toggle)하거나 두 값이 같은지 비교할 수 있습니다.
- **NOT (`~`)**: 모든 비트를 반전시킵니다. 즉, 0을 1로, 1을 0으로 바꿉니다.
- **왼쪽 시프트 (`<<`)**: 비트를 왼쪽으로 이동시키며, 이동한 만큼 값은 2의 배수로 증가합니다.
- **오른쪽 시프트 (`>>`)**: 비트를 오른쪽으로 이동시키며, 이동한 만큼 값은 2로 나눈 결과가 됩니다

예시

```jsx
int a = 5;   // 0101 (2진수)
int b = 3;   // 0011 (2진수)

int and_result = a & b; // 0001 -> 결과는 1
int or_result = a | b;  // 0111 -> 결과는 7
int xor_result = a ^ b; // 0110 -> 결과는 6
int not_result = ~a;    // 반전된 값 -> -6 (2의 보수 표현)
```

## **비트 연산을 활용한 문제 해결 방법**

비트 연산은 다양한 알고리즘 문제에서 효율적인 해결책을 제공합니다. 특히, **시간 복잡도와 공간 복잡도**를 줄이는 데 큰 도움이 됩니다. 아래는 비트 연산을 활용한 몇 가지 대표적인 문제 해결 방법입니다.

### **1. 집합 표현 및 조작**

비트를 사용하여 집합을 표현할 수 있습니다. 예를 들어, 각 비트를 집합의 원소에 대응시켜, 특정 원소가 포함되었는지를 쉽게 확인할 수 있습니다.

- **교집합(AND)**: 두 집합의 공통 원소를 구할 때 사용합니다.
- **합집합(OR)**: 두 집합의 모든 원소를 구할 때 사용합니다.
- **차집합(AND + NOT)**: 한 집합에서 다른 집합의 원소를 제거할 때 사용합니다.

### **2. 특정 비트 확인 및 설정**

특정 위치의 비트를 확인하거나 설정하는 작업은 매우 자주 사용됩니다.

- **비트 확인**: **`x & (1 << k)`**는 정수 **`x`**의 **`k`**번째 비트가 1인지 확인하는 방법입니다.
- **비트 설정**: **`x | (1 << k)`**는 **`x`**의 **`k`**번째 비트를 1로 설정합니다.

### **3. XOR을 이용한 스왑**

두 변수를 추가적인 메모리 없이 XOR 연산을 통해 교환할 수 있습니다.

```jsx
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

### **4. 홀수/짝수 판별**

숫자가 홀수인지 짝수인지를 빠르게 판단하려면 ‘x & 1’ 을 사용할 수 있습니다. 결과가 0이면 짝수, 그렇지 않으면 홀수입니다.

### **5. 빠른 곱셈 및 나눗셈**

비트 시프트를 사용하여 곱셈과 나눗셈을 최적화할 수 있습니다.

- **`x << n`**: *x*×2*n* (곱셈)
    
    x×2n
    
- **`x >> n`**: *x*/2*n* (나눗셈)
    
    x/2n
    

### **6. 하드웨어 제어 및 최적화**

비트 연산은 하드웨어 제어와 같은 저수준 프로그래밍에서 매우 유용합니다. 예를 들어, LED나 센서와 같은 장치 제어에서 특정 핀을 켜거나 끄기 위해 비트 마스크와 시프트 연산이 자주 사용됩니다.

## **결론**

비트 연산은 알고리즘 문제 해결에서 매우 강력한 도구입니다. 이를 잘 활용하면 메모리와 시간을 절약하면서도 효율적인 코드를 작성할 수 있습니다.
