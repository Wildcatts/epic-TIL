# 목차
  1. SW 문제해결
  2. 알고리즘 복잡도
  3. 비트 연산
  4. 진법
  5. 실수
---
## 1. SW 문제 해결
  - 문제 해결 과정에 대한 이해가 필요하다.
  - 문제 해결을 위한 접근 방법과 과정을 알아야 한다.

## 2. 알고리즘 복잡도 
  - 알고리즘 성능 측정을 위한 복잡도 이론
  - 시간 복잡도와 공간 복잡도 개념
  - 복잡도 분석을 통한 알고리즘 호율성 판단 방법

  ### 알고리즘 성능 측정을 위한 복잡도 이론
  알고리즘의 성능을 평가하기 위해서는 시간 복잡도와 공간 복잡도라는 두 가지 주요 개념을 사용합니다.
  이들은 각각 알고리즘이 실행되는 데 걸리는 시간과 사용하는 메모리의 양을 측정하는 지표입니다.
  이러한 복잡도 분석은 알고리즘의 효율성을 판단하고, 다양한 입력 크기에 대한 성능을 예측하는 데 중요한 역할을 합니다.

  ### 시간 복잡도와 공간 복잡도 개념
  
### **시간 복잡도(Time Complexity)**
시간 복잡도는 알고리즘이 주어진 입력 크기 *n*에 따라 얼마나 많은 시간이 소요되는지를 나타냅니다. 
일반적으로 **Big O 표기법**을 사용하여 표현하며, 이는 알고리즘의 최악의 경우 실행 시간을 상한선으로 나타냅니다.

시간 복잡도의 대표적인 예시는 다음과 같습니다:

- **O(1)**: 상수 시간 복잡도로, 입력 크기에 상관없이 일정한 시간이 소요됩니다.
- **O(log n)**: 로그 시간 복잡도로, 입력 크기가 커질수록 시간은 로그 함수에 비례해 증가합니다.
- **O(n)**: 선형 시간 복잡도로, 입력 크기에 비례하여 시간이 증가합니다.
- **O(n²)**: 이차 시간 복잡도로, 입력 크기의 제곱에 비례해 시간이 증가합니다.

### **공간 복잡도(Space Complexity)**

공간 복잡도는 알고리즘이 실행되면서 사용하는 메모리의 양을 나타냅니다. 마찬가지로 Big O 표기법을 사용하여 표현하며, 
입력 크기에 따른 메모리 사용량의 변화를 설명합니다

예를 들어:

- **O(1)**: 상수 공간 복잡도로, 입력 크기와 관계없이 일정한 메모리만 사용합니다.
- **O(n)**: 선형 공간 복잡도로, 입력 크기에 비례해 메모리를 사용합니다.

### 알고리즘 효율성을 개선하는 방법
알고리즘의 효율성을 높이기 위해서는 다음과 같은 방법들이 사용될 수 있습니다:

- 더 적은 연산으로 동일한 결과를 도출하는 최적화된 알고리즘 설계
- 적절한 데이터 구조 선택 (예: 해시 테이블 vs 배열)
- 반복적인 연산 대신 메모이제이션(Memoization) 기법 활용

따라서 코딩 테스트나 실제 개발에서 알고리즘을 설계할 때는 시간과 공간 복잡도를 모두 고려하여 
최적의 성능을 내는 방안을 찾는 것이 중요합니다.
