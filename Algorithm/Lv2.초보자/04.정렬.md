# 목차
1. 삽입정렬(Insert Sort)
2. 버블정렬(Bubble Sort)
3. 선택정렬(Selection Sort)
---
# 1. 삽입 정렬(Insertion Sort)
- 삽입 정렬의 개념과 원리
- 시간 복잡도와 최선/최악의 경우 시간 복잡
- 삽입 정렬의 구현 방법

## 삽입 정렬의 개념과 원리

- *삽입 정렬(Insertion Sort)**은 **정렬 알고리즘** 중 하나로, 배열이나 리스트를 순차적으로 탐색하면서 각 원소를 **적절한 위치에 삽입**하여 정렬하는 방식입니다. 삽입 정렬은 카드 게임에서 카드를 정렬하는 방식과 유사합니다. 즉, 이미 정렬된 부분과 아직 정렬되지 않은 부분으로 나누어, 아직 정렬되지 않은 원소를 하나씩 꺼내어 정렬된 부분에 **올바른 위치**에 삽입하는 방식입니다.

### **삽입 정렬의 동작 원리**

1. 배열의 첫 번째 요소는 이미 정렬된 것으로 간주합니다.
2. 두 번째 요소부터 시작하여, 현재 요소를 앞의 정렬된 부분과 비교합니다.
3. 비교하면서 현재 요소보다 큰 값을 만나면 그 자리에 삽입하고, 나머지 요소들을 오른쪽으로 밀어냅니다.
4. 이 과정을 배열의 끝까지 반복합니다.

### **삽입 정렬의 예시**

다음은 배열 `[5, 2, 4, 6, 1, 3]`을 삽입 정렬로 정렬하는 과정입니다:

1. 첫 번째 요소 `5`는 이미 정렬된 상태로 간주합니다.
2. 두 번째 요소 `2`를 `5`와 비교하여 `2`가 더 작으므로 `5` 앞에 삽입합니다: `[2, 5, 4, 6, 1, 3]`
3. 세 번째 요소 `4`를 `5`와 비교하여 `4`가 더 작으므로 `5` 앞에 삽입합니다: `[2, 4, 5, 6, 1, 3]`
4. 네 번째 요소 `6`은 이미 올바른 위치에 있으므로 그대로 둡니다: `[2, 4, 5, 6, 1, 3]`
5. 다섯 번째 요소 `1`을 앞의 모든 요소와 비교하여 가장 앞에 삽입합니다: `[1, 2, 4, 5, 6, 3]`
6. 마지막으로 여섯 번째 요소 `3`을 적절한 위치에 삽입합니다: `[1, 2, 3, 4, 5, 6]`

## 시간 복잡도와 최선/최악의 경우 시간 복잡도

### **시간 복잡도**

삽입 정렬의 시간 복잡도는 입력 데이터의 상태에 따라 달라집니다.

- **최선의 경우 (Best Case)**: 이미 배열이 정렬되어 있는 경우입니다. 이때는 각 요소가 자신의 자리에 그대로 있으므로 비교만 수행하고 교환이 필요하지 않습니다.
    - **시간 복잡도**: $$O(n)$$
- **최악의 경우 (Worst Case)**: 배열이 역순으로 정렬되어 있는 경우입니다. 이때는 각 요소마다 모든 이전 요소들과 비교한 후 가장 앞에 삽입해야 하므로 많은 비교와 교환이 발생합니다.
    - **시간 복잡도**: $$O(n^2)$$
- **평균적인 경우 (Average Case)**: 일반적으로 랜덤하게 섞인 배열을 처리할 때 발생하며 최악과 최선 사이의 성능을 보입니다.
    - **시간 복잡도**: $$O(n^2)$$

### **공간 복잡도**

삽입 정렬은 추가적인 메모리를 거의 사용하지 않으므로 **공간 복잡도**는 $$O(1)$$입니다.

### **삽입 정렬 시간 복잡도 요약**

| 경우 | 시간 복잡도 |
| --- | --- |
| 최선 | $$O(n)$$ |
| 최악 | $$O(n^2)$$ |
| 평균 | $$O(n^2)$$ |

### **삽입 정렬의 장단점**

- **장점**:
    - 작은 데이터셋에서 효율적입니다.
    - 데이터가 거의 정렬된 경우 매우 빠릅니다.
    - 안정적인 정렬 알고리즘으로 동일한 값들의 순서가 유지됩니다.
    - 추가 메모리가 거의 필요하지 않습니다.
- **단점**:
    - 큰 데이터셋에서는 비효율적이며 $$O(n^2)$$ 시간이 소요됩니다.

## 삽입 정렬의 구현 방법

다음은 Python으로 구현한 삽입 정렬 알고리즘입니다:

```python
def insertion_sort(arr):
    # 배열의 두 번째 원소부터 시작
    for i in range(1, len(arr)):
        key = arr[i] # 현재 위치에서 비교할 값
        j = i - 1

        # key 값보다 큰 값들은 한 칸씩 뒤로 이동
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1

        # key 값을 올바른 위치에 삽입
        arr[j + 1] = key

# 테스트
arr = [5, 2, 9, 1, 5, 6]
insertion_sort(arr)
print(arr)

```

출력:

```
[1, 2, 5, 5, 6, 9]

```

### **C 언어로 구현한 삽입 정렬**

```c
#include <stdio.h>

void insertion_sort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;

        // key보다 큰 값들을 한 칸씩 뒤로 이동
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }

        // key 값을 올바른 위치에 삽입
        arr[j + 1] = key;
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);

    insertion_sort(arr, n);

    printf("Sorted array: \\n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    return 0;
}

```

출력:

```
Sorted array:
5 6 11 12 13

```

## 결론

- *삽입 정렬(Insertion Sort)**은 간단하고 직관적인 알고리즘으로 작은 데이터셋이나 거의 정렬된 데이터셋에서 매우 효율적입니다.
- 최선의 경우 시간 복잡도는 $$O(n)$$이지만 최악 및 평균적인 경우에는 $$O(n^2)$$ 시간이 소요되어 큰 데이터셋에서는 비효율적일 수 있습니다.
- 구현이 쉽고 안정적인 특성을 가지며 추가 메모리가 거의 필요하지 않다는 장점이 있습니다.

# 2. 버블 정렬(Bubble Sort)
- 버블 정렬의 개념과 원리
- 시간 복잡도와 최선/최악의 경우
- 버블 정렬의 구현 방법

## 버블 정렬의 개념과 원리

- **버블 정렬(Bubble Sort)**은 가장 간단한 정렬 알고리즘 중 하나입니다. 인접한 두 요소를 비교하여 잘못된 순서일 경우 서로 교환하는 방식으로 동작합니다. 이 과정을 반복하면서 가장 큰 값이 배열의 끝으로 "거품처럼" 떠오르는 것에서 이름이 유래되었습니다.

### **버블 정렬의 동작 원리**

1. 배열의 첫 번째 요소와 두 번째 요소를 비교합니다.
2. 두 요소가 잘못된 순서(앞의 값이 더 큰 경우)라면 위치를 교환합니다.
3. 다음 두 요소를 비교하고, 이 작업을 배열의 끝까지 반복합니다.
4. 한 번의 패스가 끝나면 가장 큰 값이 배열의 끝에 위치하게 됩니다.
5. 이 과정을 배열이 완전히 정렬될 때까지 반복합니다.

### **버블 정렬 예시**

다음은 배열 `[5, 1, 4, 2, 8]`을 버블 정렬로 정렬하는 과정입니다:

1. 첫 번째 패스:
    - `5`와 `1` 비교 → 교환: `[1, 5, 4, 2, 8]`
    - `5`와 `4` 비교 → 교환: `[1, 4, 5, 2, 8]`
    - `5`와 `2` 비교 → 교환: `[1, 4, 2, 5, 8]`
    - `5`와 `8` 비교 → 교환 없음
    - 결과: `[1, 4, 2, 5, 8]`
2. 두 번째 패스:
    - `1`과 `4` 비교 → 교환 없음
    - `4`와 `2` 비교 → 교환: `[1, 2, 4, 5, 8]`
    - `4`와 `5` 비교 → 교환 없음
    - 결과: `[1, 2, 4, 5, 8]`
3. 세 번째 패스:
    - `1`과 `2` 비교 → 교환 없음
    - `2`와 `4` 비교 → 교환 없음
    - 결과: `[1, 2, 4, 5, 8]`

이미 배열이 정렬되었으므로 더 이상 패스를 진행하지 않고 종료됩니다.

## 시간 복잡도와 최선/최악의 경우

### **시간 복잡도**

버블 정렬은 모든 요소를 반복적으로 비교하고 교환하기 때문에 시간 복잡도가 입력 데이터의 상태에 따라 달라집니다.

- **최선의 경우 (Best Case)**: 배열이 이미 정렬된 상태입니다. 이때는 한 번의 패스만으로 정렬 여부를 확인할 수 있습니다.
    - **시간 복잡도**: $$O(n)$$
- **최악의 경우 (Worst Case)**: 배열이 역순으로 정렬된 경우입니다. 모든 요소가 잘못된 위치에 있어 여러 번 교환해야 합니다.
    - **시간 복잡도**: $$O(n^2)$$
- **평균적인 경우 (Average Case)**: 일반적으로 랜덤하게 섞인 배열을 처리할 때 발생하며, 최악과 최선 사이의 성능을 보입니다.
    - **시간 복잡도**: $$O(n^2)$$

### **공간 복잡도**

- 버블 정렬은 추가적인 메모리를 거의 사용하지 않으므로 공간 복잡도는 $$O(1)$$입니다.

### **버블 정렬 시간 복잡도 요약**

| 경우 | 시간 복잡도 |
| --- | --- |
| 최선 | $$O(n)$$ |
| 최악 | $$O(n^2)$$ |
| 평균 | $$O(n^2)$$ |

### **버블 정렬의 장단점**

- **장점**:
    - 구현이 매우 간단합니다.
    - 코드가 직관적이고 이해하기 쉽습니다.
    - 이미 거의 정렬된 데이터에 대해서는 효율적일 수 있습니다(최선의 경우 $$O(n)$$).
- **단점**:
    - 큰 데이터셋에서는 매우 비효율적입니다(최악 및 평균 시간 복잡도가 $$O(n^2)$$).
    - 다른 효율적인 알고리즘에 비해 실무에서 거의 사용되지 않습니다.

## 버블 정렬의 구현 방법

다음은 Python으로 구현한 버블 정렬 알고리즘입니다:

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break

# 테스트
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Sorted array:", arr)
```

출력:

```
Sorted array: [11, 12, 22, 25, 34, 64, 90]
```

### **C 언어로 구현한 버블 정렬**

```c
#include <stdio.h>

void bubble_sort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        int swapped = 0;
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                swapped = 1;
            }
        }
        if (!swapped)
            break;
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr)/sizeof(arr[0]);

    bubble_sort(arr, n);

    printf("Sorted array: \n");
    for (int i=0; i < n; i++)
        printf("%d ", arr[i]);

    return 0;
}
```

출력:

```
Sorted array:
11 12 22 25 34 64 90
```

## 결론

- **버블 정렬(Bubble Sort)**은 인접한 두 요소를 반복적으로 비교하고 필요한 경우 교환하는 방식으로 동작하는 매우 간단한 알고리즘입니다.
- 최선의 경우에는 $$O(n)$$의 성능을 보일 수 있지만, 일반적으로는 $$O(n^2)$$의 시간 복잡도를 가지기 때문에 큰 데이터셋에서는 비효율적입니다.
- 구현이 매우 직관적이고 간단하지만, 실무에서는 더 효율적인 알고리즘(예: 퀵 정렬이나 병합 정렬)이 주로 사용됩니다.

  # 3. 선택 정렬(Selection Sort)
  - 선택 정렬의 개념과 원리
- 시간 복잡도와 최선/최악의 경우 시간 복잡도
- 선택 정렬의 구현 방법

## 선택 정렬의 개념과 원리

- *선택 정렬(Selection Sort)**은 가장 간단한 정렬 알고리즘 중 하나로, 배열에서 **최소값**을 찾아 첫 번째 위치에 놓고, 그 다음 최소값을 찾아 두 번째 위치에 놓는 방식으로 동작합니다. 즉, 매번 남은 부분에서 가장 작은 값을 선택하여 앞쪽으로 이동시키는 방식입니다.

### **선택 정렬의 동작 원리**

1. 주어진 배열에서 **가장 작은 값을 찾아** 배열의 첫 번째 요소와 교환합니다.
2. 두 번째로 작은 값을 찾아 두 번째 요소와 교환합니다.
3. 이 과정을 배열의 끝까지 반복하여 배열을 정렬합니다.

### **선택 정렬의 예시**

다음은 배열 `[64, 25, 12, 22, 11]`을 선택 정렬로 정렬하는 과정입니다:

1. 첫 번째 패스:
    - 배열에서 가장 작은 값 `11`을 찾아 첫 번째 요소 `64`와 교환: `[11, 25, 12, 22, 64]`
2. 두 번째 패스:
    - 나머지 배열 `[25, 12, 22, 64]`에서 가장 작은 값 `12`를 찾아 두 번째 요소 `25`와 교환: `[11, 12, 25, 22, 64]`
3. 세 번째 패스:
    - 나머지 배열 `[25, 22, 64]`에서 가장 작은 값 `22`를 찾아 세 번째 요소 `25`와 교환: `[11, 12, 22, 25, 64]`
4. 네 번째 패스:
    - 나머지 배열 `[25, 64]`에서 가장 작은 값 `25`는 이미 제자리에 있으므로 교환하지 않음: `[11, 12, 22, 25, 64]`
5. 다섯 번째 패스:
    - 마지막 남은 값 `64`는 이미 제자리에 있으므로 교환하지 않음: `[11, 12, 22, 25, 64]`

결과적으로 배열이 완전히 정렬됩니다.

## 시간 복잡도와 최선/최악의 경우 시간 복잡도

### **시간 복잡도**

선택 정렬은 **입력 데이터의 상태에 상관없이** 항상 모든 요소를 비교하고 최소값을 찾기 때문에 최선과 최악의 경우 모두 동일한 시간 복잡도를 가집니다.

- **최선의 경우 (Best Case)**: 이미 배열이 정렬되어 있더라도 모든 요소를 비교해야 하므로 시간 복잡도는 $$O(n^2)$$입니다.
- **최악의 경우 (Worst Case)**: 배열이 역순으로 정렬되어 있을 때도 마찬가지로 모든 요소를 비교해야 하므로 시간 복잡도는 $$O(n^2)$$입니다.
- **평균적인 경우 (Average Case)**: 랜덤하게 섞인 배열을 처리할 때도 동일하게 $$O(n^2)$$ 시간이 소요됩니다.

### **공간 복잡도**

- 선택 정렬은 추가적인 메모리를 거의 사용하지 않으므로 **공간 복잡도**는 $$O(1)$$입니다.

### **선택 정렬 시간 복잡도 요약**

| 경우 | 시간 복잡도 |
| --- | --- |
| 최선 | $$O(n^2)$$ |
| 최악 | $$O(n^2)$$ |
| 평균 | $$O(n^2)$$ |

### **선택 정렬의 장단점**

- **장점**:
    - 구현이 매우 간단하고 직관적입니다.
    - 추가 메모리를 거의 사용하지 않는 **제자리(in-place) 정렬**입니다.
    - 데이터의 크기가 작거나 메모리 사용이 중요한 상황에서 유용할 수 있습니다.
- **단점**:
    - 시간 복잡도가 $$O(n^2)$$으로 비효율적이기 때문에 큰 데이터셋에서는 성능이 좋지 않습니다.
    - 안정적인 정렬 알고리즘이 아닙니다. 즉, 동일한 값들의 순서가 유지되지 않을 수 있습니다.

## 선택 정렬의 구현 방법

다음은 Python으로 구현한 선택 정렬 알고리즘입니다:

```python
def selection_sort(arr):
    n = len(arr)

    # 배열 전체를 순회
    for i in range(n):
        # 최소값을 찾기 위한 인덱스
        min_idx = i

        # i번째 이후로 최소값을 찾음
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j

        # 최소값을 현재 위치(i)로 이동
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

# 테스트
arr = [64, 25, 12, 22, 11]
selection_sort(arr)
print("Sorted array:", arr)

```

출력:

```
Sorted array: [11, 12, 22, 25, 64]

```

### **C 언어로 구현한 선택 정렬**

```c
#include <stdio.h>

void selection_sort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        // 현재 위치에서 최소값을 찾기 위한 인덱스
        int min_idx = i;

        // i 이후로 최소값을 찾음
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }

        // 최소값을 현재 위치(i)로 이동
        int temp = arr[i];
        arr[i] = arr[min_idx];
        arr[min_idx] = temp;
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr)/sizeof(arr[0]);

    selection_sort(arr, n);

    printf("Sorted array: \\n");
    for (int i=0; i < n; i++)
        printf("%d ", arr[i]);

    return 0;
}

```

출력:

```
Sorted array:
11 12 22 25 64

```

## 결론

- *선택 정렬(Selection Sort)**은 매번 남은 부분에서 가장 작은 값을 선택하여 앞쪽으로 이동시키는 방식으로 동작하는 간단한 알고리즘입니다.
- 입력 데이터의 상태와 관계없이 항상 $$O(n^2)$$의 시간 복잡도를 가지며 큰 데이터셋에서는 비효율적입니다.
- 그러나 구현이 쉽고 추가 메모리를 거의 사용하지 않기 때문에 메모리가 제한된 상황이나 데이터 크기가 작을 때 유용할 수 있습니다.
