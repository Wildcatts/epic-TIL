## 배열 개념
배열의 각 데이터는 낮은 주소에소 높은 주소 방향으로 연이어 할당된다.  
| arr[0] | arr[1] | arr[2] | arr[3] | arr[4] | arr[5] |
|---|---|---|---|---|---|
| 5792 | 5824 | 5856 | 5888 | 5920 | 5952 |
- 2차원 배열도 역시 저렇게 생성된다  

| arr[0][0] | arr[0][1] | arr[0][2] | arr[1][0] | arr[1][1] | arr[1][2] |
|---|---|---|---|---|---|
| 5792 | 5824 | 5856 | 5888 | 5920 | 5952 |

## 배열의 효율성
### 배열 연산의 시간 복잡도
- 배열은 모든 위치에 있는 데이터에 한번에 접근할 수 있기 때문에 시간 복잡도는 O(1)이다.  
- 하지만 특정한 경우에 데이터 추가나 삭제에 드는 비용이 많다. 시간 복잡도는 __O(N)__ 이다.  (기존 데이터를 한칸씩 밀어야 함)

## 자주 활용하는 리스트 기법
### append()
### + 연산자
### insert()
```python
my_list = [1, 2, 3, 4, 5]
my_list.inset(2, 999)  # [1, 2, 999, 3, 4, 5]
```
### pop()
삭제한 데이터의 값을 반환해서 사용할 수 있다.
### remove()
인수로 받은 값이 처음 등장하는 위치의 데이터를 삭제한다.
```python
my_list = [1, 2, 3, 2, 4, 5]
my_list.remove(2)  # [1, 3, 2, 4, 5]
```
### 리스트 컴프리헨션으로 데이터에 특정 연산 적용
리스트 컴프리헨션은 연산이 끝난 리스트를 반활할 뿐이지 연산 대상 리스트를 바꾸지 않는다.
```python
numbers = [1, 2, 3, 4, 5]
squares = [num**2 for num in numbers]
print(numbers)  # [1, 2, 3, 4, 5]
print(squares)  # [1, 4, 9, 16, 25]
```
### 리스트 연관 메서드
1. len()
2. index()
  - 특정 데이터가 처음 등장한 인덱스를 반환
3. sort()
4. count()
  - 특정 데이터 개수를 반환
